<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>DataCrumbs</title>
    <link href="weave-html/c3.css" rel="stylesheet" type="text/css">
    <link href="weave-html/ol.css" rel="stylesheet" type="text/css">
    <link href="weave-html/ol-custom.css" rel="stylesheet" type="text/css">
    <link href="node_modules/font-awesome/css/font-awesome.css" rel="stylesheet" type="text/css">
    <link href="weave-html/datagrid.css" rel="stylesheet" type="text/css">
    <link href="weave-html/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="weave-html/react-bootstrap-table-all.min.css">
    <link href="weave-html/weave.css" rel="stylesheet" type="text/css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.css" type="text/css"/>
</head>
<style>
    .box {
        font: 10px sans-serif;
    }

    .box line,
    .box rect,
    .box circle {
        fill: #fff;
        stroke: #000;
        stroke-width: 1.5px;
    }

    .box .center {
        stroke-dasharray: 3,3;
    }

    .box .outlier {
        fill: none;
        stroke: #ccc;
    }
    .chart{
        width: 900px;
        height: 900px;
    }
</style>
<body>
<!-- REACT--->
<script src="node_modules/react/dist/react.js"></script>
<script src="node_modules/react-dom/dist/react-dom.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.js"></script><!--C3-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.14/d3.min.js"></script><!--C3-->
<!--<script src="https://code.jquery.com/jquery-2.2.0.min.js"></script-->

<!--Weave libraries-->
<script src="weavejs/WeaveJS.js"></script>
<script>new WeaveJS().start();</script>
<script src="weave-html/libs.js"></script>
<script src="weave-html/WeaveUI.js"></script>
<svg class = 'chart' id="content" style="height: 800px; width : 1000px"></svg>
<div id="weaveElt" style="height: 700px; width : 100%"></div>
<script src="node_modules/jquery/dist/jquery.min.js"></script>
<!-- react crumb bundle--->
<!--<script src="dist/bundle.js"></script>-->
<script>
    //C3 code
    var elementID = document.getElementById("content");

    //MAP THIS DATA TO DATA FROM WEAVE
    var DateFilled = ['x', '2016-02-11', '2016-02-12', '2016-02-13', '2016-02-14', '2016-02-15'];
    var MME = ['MME', 200,50, 170, 130, 180];
    var mylineData = ['trend',70, 40, 60, 100, 140];
    var boxPlotCoordinates = ['BoxPlots',125.8, 121, 132, 116.8, 162];
    //MAP THIS DATA TO DATA FROM WEAVE END


    var myData = {};
    myData.x = 'x';	myData.xFormat = "%Y-%m-%d";

    myData.columns = [];
    myData.columns.push(MME);
    myData.columns.push(DateFilled);
    myData.columns.push(mylineData);
    myData.columns.push(boxPlotCoordinates);

    myData.type = 'scatter';
    myData.types = {
        trend : 'line'

    };

    var chart = c3.generate({
        bindto : d3.select('#content'),
        data: myData,
        axis: {
            x: {
                type: 'timeseries',
                tick: {format: "%Y-%m-%d"}
            }

        }

    });

    //D3 code for box plots

    (function() {

// Inspired by http://informationandvisualization.de/blog/box-plot
        d3.box = function() {
            var width = 1,
                    height = 1,
                    duration = 0,
                    domain = null,
                    value = Number,
                    whiskers = boxWhiskers,
                    quartiles = boxQuartiles,
                    tickFormat = null;

            // For each small multipleâ€¦
            function box(g) {
                g.each(function(d, i) {
                    d = d.map(value).sort(d3.ascending);
                    var g = d3.select(this),
                            n = d.length,
                            min = d[0],
                            max = d[n - 1];

                    // Compute quartiles. Must return exactly 3 elements.
                    var quartileData = d.quartiles = quartiles(d);

                    // Compute whiskers. Must return exactly 2 elements, or null.
                    var whiskerIndices = whiskers && whiskers.call(this, d, i),
                            whiskerData = whiskerIndices && whiskerIndices.map(function(i) { return d[i]; });

                    // Compute outliers. If no whiskers are specified, all data are "outliers".
                    // We compute the outliers as indices, so that we can join across transitions!
                    var outlierIndices = whiskerIndices
                            ? d3.range(0, whiskerIndices[0]).concat(d3.range(whiskerIndices[1] + 1, n))
                            : d3.range(n);

                    // Compute the new x-scale.
                    var x1 = d3.scale.linear()
                            .domain(domain && domain.call(this, d, i) || [min, max])
                            .range([height, 0]);

                    // Retrieve the old x-scale, if this is an update.
                    var x0 = this.__chart__ || d3.scale.linear()
                                    .domain([0, Infinity])
                                    .range(x1.range());

                    // Stash the new scale.
                    this.__chart__ = x1;

                    // Note: the box, median, and box tick elements are fixed in number,
                    // so we only have to handle enter and update. In contrast, the outliers
                    // and other elements are variable, so we need to exit them! Variable
                    // elements also fade in and out.

                    // Update center line: the vertical line spanning the whiskers.
                    var center = g.selectAll("line.center")
                            .data(whiskerData ? [whiskerData] : []);

                    center.enter().insert("line", "rect")
                            .attr("class", "center")
                            .attr("x1", width / 2)
                            .attr("y1", function(d) { return x0(d[0]); })
                            .attr("x2", width / 2)
                            .attr("y2", function(d) { return x0(d[1]); })
                            .style("opacity", 1e-6)
                            .transition()
                            .duration(duration)
                            .style("opacity", 1)
                            .attr("y1", function(d) { return x1(d[0]); })
                            .attr("y2", function(d) { return x1(d[1]); });

                    center.transition()
                            .duration(duration)
                            .style("opacity", 1)
                            .attr("y1", function(d) { return x1(d[0]); })
                            .attr("y2", function(d) { return x1(d[1]); });

                    center.exit().transition()
                            .duration(duration)
                            .style("opacity", 1e-6)
                            .attr("y1", function(d) { return x1(d[0]); })
                            .attr("y2", function(d) { return x1(d[1]); })
                            .remove();

                    // Update innerquartile box.
                    var box = g.selectAll("rect.box")
                            .data([quartileData]);

                    box.enter().append("rect")
                            .attr("class", "box")
                            .attr("x", 0)
                            .attr("y", function(d) { return x0(d[2]); })
                            .attr("width", width)
                            .attr("height", function(d) { return x0(d[0]) - x0(d[2]); })
                            .transition()
                            .duration(duration)
                            .attr("y", function(d) { return x1(d[2]); })
                            .attr("height", function(d) { return x1(d[0]) - x1(d[2]); });

                    box.transition()
                            .duration(duration)
                            .attr("y", function(d) { return x1(d[2]); })
                            .attr("height", function(d) { return x1(d[0]) - x1(d[2]); });

                    // Update median line.
                    var medianLine = g.selectAll("line.median")
                            .data([quartileData[1]]);

                    medianLine.enter().append("line")
                            .attr("class", "median")
                            .attr("x1", 0)
                            .attr("y1", x0)
                            .attr("x2", width)
                            .attr("y2", x0)
                            .transition()
                            .duration(duration)
                            .attr("y1", x1)
                            .attr("y2", x1);

                    medianLine.transition()
                            .duration(duration)
                            .attr("y1", x1)
                            .attr("y2", x1);

                    // Update whiskers.
                    var whisker = g.selectAll("line.whisker")
                            .data(whiskerData || []);

                    whisker.enter().insert("line", "circle, text")
                            .attr("class", "whisker")
                            .attr("x1", 0)
                            .attr("y1", x0)
                            .attr("x2", width)
                            .attr("y2", x0)
                            .style("opacity", 1e-6)
                            .transition()
                            .duration(duration)
                            .attr("y1", x1)
                            .attr("y2", x1)
                            .style("opacity", 1);

                    whisker.transition()
                            .duration(duration)
                            .attr("y1", x1)
                            .attr("y2", x1)
                            .style("opacity", 1);

                    whisker.exit().transition()
                            .duration(duration)
                            .attr("y1", x1)
                            .attr("y2", x1)
                            .style("opacity", 1e-6)
                            .remove();

                    // Update outliers.
                    var outlier = g.selectAll("circle.outlier")
                            .data(outlierIndices, Number);

                    outlier.enter().insert("circle", "text")
                            .attr("class", "outlier")
                            .attr("r", 5)
                            .attr("cx", width / 2)
                            .attr("cy", function(i) { return x0(d[i]); })
                            .style("opacity", 1e-6)
                            .transition()
                            .duration(duration)
                            .attr("cy", function(i) { return x1(d[i]); })
                            .style("opacity", 1);

                    outlier.transition()
                            .duration(duration)
                            .attr("cy", function(i) { return x1(d[i]); })
                            .style("opacity", 1);

                    outlier.exit().transition()
                            .duration(duration)
                            .attr("cy", function(i) { return x1(d[i]); })
                            .style("opacity", 1e-6)
                            .remove();

                    // Compute the tick format.
                    var format = tickFormat || x1.tickFormat(8);

                    // Update box ticks.
                    var boxTick = g.selectAll("text.box")
                            .data(quartileData);

                    boxTick.enter().append("text")
                            .attr("class", "box")
                            .attr("dy", ".3em")
                            .attr("dx", function(d, i) { return i & 1 ? 6 : -6 })
                            .attr("x", function(d, i) { return i & 1 ? width : 0 })
                            .attr("y", x0)
                            .attr("text-anchor", function(d, i) { return i & 1 ? "start" : "end"; })
                            .text(format)
                            .transition()
                            .duration(duration)
                            .attr("y", x1);

                    boxTick.transition()
                            .duration(duration)
                            .text(format)
                            .attr("y", x1);

                    // Update whisker ticks. These are handled separately from the box
                    // ticks because they may or may not exist, and we want don't want
                    // to join box ticks pre-transition with whisker ticks post-.
                    var whiskerTick = g.selectAll("text.whisker")
                            .data(whiskerData || []);

                    whiskerTick.enter().append("text")
                            .attr("class", "whisker")
                            .attr("dy", ".3em")
                            .attr("dx", 6)
                            .attr("x", width)
                            .attr("y", x0)
                            .text(format)
                            .style("opacity", 1e-6)
                            .transition()
                            .duration(duration)
                            .attr("y", x1)
                            .style("opacity", 1);

                    whiskerTick.transition()
                            .duration(duration)
                            .text(format)
                            .attr("y", x1)
                            .style("opacity", 1);

                    whiskerTick.exit().transition()
                            .duration(duration)
                            .attr("y", x1)
                            .style("opacity", 1e-6)
                            .remove();
                });
                d3.timer.flush();
            }

            box.width = function(x) {
                if (!arguments.length) return width;
                width = x;
                return box;
            };

            box.height = function(x) {
                if (!arguments.length) return height;
                height = x;
                return box;
            };

            box.tickFormat = function(x) {
                if (!arguments.length) return tickFormat;
                tickFormat = x;
                return box;
            };

            box.duration = function(x) {
                if (!arguments.length) return duration;
                duration = x;
                return box;
            };

            box.domain = function(x) {
                if (!arguments.length) return domain;
                domain = x == null ? x : d3.functor(x);
                return box;
            };

            box.value = function(x) {
                if (!arguments.length) return value;
                value = x;
                return box;
            };

            box.whiskers = function(x) {
                if (!arguments.length) return whiskers;
                whiskers = x;
                return box;
            };

            box.quartiles = function(x) {
                if (!arguments.length) return quartiles;
                quartiles = x;
                return box;
            };

            return box;
        };

        function boxWhiskers(d) {
            return [0, d.length - 1];
        }

        function boxQuartiles(d) {
            return [
                d3.quantile(d, .25),
                d3.quantile(d, .5),
                d3.quantile(d, .75)
            ];
        }

    })();

    //My COde
    var margin = {top: 10, right: 50, bottom: 20, left: 50},
            width = 120 - margin.left - margin.right,
            height = 800 - margin.top - margin.bottom;

    var min = Infinity,
            max = -Infinity;

    var chart2 = d3.box()
            .whiskers(iqr(1.5))
            .width(width)
            .height(height);

    //*********************MAP THIS DATA TO DATA FROM WEAVE
    //right now pulls data from a csv to create boxes, we need a weave column here
    d3.csv("./lib/morley.csv", function(error, csv) {
        if (error) throw error;

        var data = [];


        csv.forEach(function(x) {
            var e = Math.floor(x.Expt -1),
                    r = Math.floor(x.Run - 1),
                    s = Math.floor(x.Speed),
                    d = data[e];
            if (!d) d = data[e] = [s];

            else d.push(s);
            if (s > max) max = s;
            if (s < min) min = s;
        });
    //*********************MAP THIS DATA TO DATA FROM WEAVE END

        chart2.domain([min, max]);

        var circles = d3.select('#content').selectAll('g').filter('.c3-circles-BoxPlots').selectAll('circle')[0];

        var svg = d3.select("#content").selectAll("svg")
                .data(data)
                .enter()
                .insert("g","svg").style("class", 'box')
                .attr("transform", function(d,index) {
                    return "translate(" + (margin.left + Number(d3.select(circles[index]).attr("cx")) -.5*width) + "," + margin.top + ")"
                })
                .call(chart2);

        console.log("data", data);
    });

    // Returns a function to compute the interquartile range.
    function iqr(k) {
        return function(d, i) {
            var q1 = d.quartiles[0],
                    q3 = d.quartiles[2],
                    iqr = (q3 - q1) * k,
                    i = -1,
                    j = d.length;
            while (d[++i] < q1 - iqr);
            while (d[--j] > q3 + iqr);
            return [i, j];
        };
    }
</script>
</body>
</html>